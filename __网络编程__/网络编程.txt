2018年7月6日,星期五
网络编程：
    目的：数据的传输
    网络数据传输是一个复杂的过程
OSI七层模型：
————————>
网络通信标准化模型
-------------------------------------------------------------------------------
    应用层：提供用户服务，具体内容由特定程序规定
    表示层：数据的压缩优化
    会话层：建立应用连接，选择传输层服务
    传输层：提供不同的传输服务，流量控制
    网络层：路由选择，网络互连
    链路层：提供链路交换，具体消息以帧发送
    物理层：物理硬件，接口，网卡，线路
-------------------------------------------------------------------------------
OSI七层模型优点：
    将功能分开，降低网络传输中的耦合性，每一部分完成自己的功能，可以在开发和实施的过程中各司其职。
    高内聚：单个模块功能尽量单一
    低耦合：模块之间尽量减少关联和影响
--------------------------------------------------------------------------------
转换为四层模型：
    应用层---->应用层  表示层  会话层
    传输层---->传输层
    网络层---->网络层
    物理链路层------>物理层 和 链路层
--------------------------------------------------------------------------------
    五层模型：(tcp/ip模型)：
    应用层
    传输层
    网络层
    链路层
    物理层
-------------------------------------------------------------------------------
协议(网络协议)：在网络通信中，各方必须遵守的规定，包括建立什么样的连接，消息结构等
    应用层：TFTP HTTP DNS SMTP
    传输层：TCP UDP
    网络层：IP
    物理层：IEEE
-------------------------------------------------------------------------------
网络基本概念：
        主机："localhost" 表示本台计算机
        网络上：只在本地测试使用
         "localhost"    "127.0.0.1"
如果想在网络上进行测试
"0.0.0.0" " " "172.0.0.1"
获取主机ip
socket.gethostbyname("tedu")
什么是ip地址：
在网络上用于区分一台计算机的网络地址
Ipv4：点分十进制    e.g. 192.168.1.72   范围：0-255
           32位二进制表示
Ipv6：2的128次方
网络连接测试命令：ping ip地址
-------------------------------------------------------------------------------
特殊ip
    127.0.0.1   本地测试ip
    0.0.0.0    本地网卡通用ip
    192.168.1.0    表示当前网段
    192.168.1.1    表示网关
    192.168.1.255  广播地址
    子网掩码：255.255.255.0

获取服务主机信息：
    socket.gethostbyaddr('www.ahzcgg.com')
转换为十六进制
    In [11]: socket.inet_aton('127.0.0.1')
    Out[11]: b'\x7f\x00\x00\x01'
转换为十进制
    In [12]: socket.inet_atoa(b'\x7f\x00\x00\x01')
    Out[12]: '127.0.0.1'
域名：网络服务器IP地址的名称
    URL：在网络上定位某个资源位置的字串
端口号：端口号是网路地址的一部分，在一个系统中，每个网络应用都会有一个唯一的端口号，取来区别其他应用，接受发往这个端口的消息
数字端口：1-65535
1--255：一些众所周知的端口
256--1023：系统应用
1024--65535：自用
推荐大于10000端口
-------------------------------------------------------------------------------
获取应用使用的端口号：
In [12]: socket.getservbyname('mysql')
Out[12]: 3306
-------------------------------------------------------------------------------
传输层服务：
面向连接的传输服务--->TCP协议
       传输特征
*提供可靠的传输服务
    可靠性表现：数据在传输过程中，无失序，无差错，无重复，无丢失
*传输中有建立和断开连接的过程
    三次握手：建立数据传输两端的持续连接
        1.客户端向服务器发起连接请求
        2.服务器收到连接请求进行确认，返回报文
        3.客户端收到服务器确认进行连接创建
    四次挥手：断开连接的两端，保证数据的传输完整
        1.主动发送报文，告知被动方要断开连接
        2.被动方返回报文，告知收到请求，准备断开
        3.被动方再次发送报文，告知准备完毕可以断开
        4.主动方发送报文完成断开
适用情况：
    文件的上传下载，邮件，网页获取
            
面向无连接的传输服务---->UDP协议
    传输特征：
        *不保证传输的可靠性
        *无需建立三次握手和四次挥手的连接断开过程
        *消息的收发比较自由，不受其他约束
适用情况：
    网络情况较差，对可靠性要求不高，收发消息的两端不适合建立固定连接
比如：
    网络视频，群聊，广播
-------------------------------------------------------------------------------
socket套接字编程：
    目的：通过编程语言提供的函数接口进行组合，更简单的完成基于tcp和udp通信的网络编程
套接字：完成上述目标的编程方法方案
    流式套接字(sock_stream):传输层基于tcp的协议进行通信
    数据报套接字(sock_dfram):传输层寄语udp的协议进行通信
    底层套接字(sock_ram)：访问底层协议的套接字
创建套接字---->绑定IP端口号----->监听套接字----->等待接受客户端连接----->接受消息---->发送消息---->关闭套接字
-------------------------------------------------------------------------------
Tcp套接字：
    import socket
    #创建套接字
    socket.socket(socket_family=AF_INET,socket_type=SOCK_STREAM,proto=0)
    功能：创建一个套接字
    参数：socket_family  选择地址族类型   AF_INET 表示 IPV4
          socket_type   选择套接字类型   SOCK_STREAM 流式
                                        SOCK_DGRAM 数据报
          proto         通常为0  (表示选择子协议)
返回值：
    返回一个套接字对象
2.绑定ip端口
    sockfd.bind()
功能：
    绑定ip和端口
参数：
    二元元组，第一项为ip，第二项为端口号
    例如：('192.168.1.2',8888)
-------------------------------------------------------------------------------
tcp流式套接字和udp数据报套接字区别：

    1.流式套接字采用字节流的方式传输数据，而数据报套接字以数据报形式传输
    2.tcp会产生粘包现象，udp消息是有边界的不会粘包
    3.tcp传输是建立在连接的基础上，保证传输的可靠性，而udp一次接受一个数据报，不保证数据的完整性
    4.tcp需要依赖listen accept建立连接，udp不用
    5.tcp收发消息使用recv send,udp用recvfrom sendto

补充：
    sendall()
    功能：
        同send()作为tcp消息发送
    参数：同send()
    返回值：成功返回None
            失败返回异常
-------------------------------------------------------------------------------
socket模块和套接字属性：

    (s表示一个套接字对象)
s.type:获取套接字类型
s.family:获取地址族类型
*s.fileno()
    ·获取套接字文件描述符
    ·每一个IO操作，系统都会为其分配不同的正整数，该正整数即为此IO操作的文件描述符。
s.getsockname()
    ·获取套接字的绑定地址
*s.getpeername()
    ·获取连接套接字另一端的地址
*s.setsockopt(level,optname,value)
    ·设置套接字选项，丰富修改原有套接字的功能
    ·参数：level:获取选项的类型
    ·optname 每个选项类型中的子选项
    ·value  为选项设置成什么样的值
s.getsockopt(level,optname)
    ·获取套接字选项的值
--------------------------------------------------------------------------------
udp套接字应用之广播：
    一点发送多点接收
    目标地址：广播地址，每个网段内最大的地址
    172.60.50.255 ----><broadcast>
--------------------------------------------------------------------------------
tcp应用之HTTP传输：
    http协议 ---->超文本传输协议   应用层协议
    用途：网页的获取，基于网站的数据传输
特点：
    1.应用层协议，传输层使用tcp传输
    2.简单灵活，和多种语言对接方便
    3.无状态协议，不记录用户的通信内容
    4.成熟稳定 http1.1
工作模式：
    使用http双方均遵循http协议规定发送接收消息体
    请求方根据协议组织请求内容发送给对方
    服务方，收到内容按照协议解析
    服务方，将回复内容根据协议组织发送给请求方
    请求方，收到回复根据协议解析
作业：
    写一个tcp服务端和客户端，完成一个文件的传输过程
    了解http协议更多的内容
--------------------------------------------------------------------------------
http请求      request
    ·请求格式：
        请求行
            GET            /                                HTTP/1.1
          请求种类       请求内容                             协议版本
            GET        获取网络资源
            POST       提交一定的附加数据，得到返回结果
            HEAD       获取响应头
            PUT        更新服务器资源
            DELETE     删除服务器资源
            CONNECT    预留
            TRACE      测试
            OPTTIONS   获取服务器性能
        请求头
            ·对请求内容的具体描述
            *以键值对的形式对请求信息进行描述
                Accept:text/html
        空行
        请求体
            ·提交具体的请求参数
--------------------------------------------------------------------------------
http响应   Response

1.响应行   反馈具体的响应情况
        HTTP/1.1            200                           ok
        版本信息            响应码                       附加信息
           略               1xx                  提示信息  表示请求已经接受
                            2xx                         响应成功
                            3xx                     响应需要重新请定向
                            4xx                       客户端错误
                            5xx                       服务器错误
        ·常见响应码：
            200     成功
            404     请求资源不存在
            401     没有访问权限
            500     服务器发生未知错误
            503     服务器暂时无法执行
--------------------------------------------------------------------------------
2.响应头    对响应信息的具体描述
    ·和请求行类似
3.空行
4.响应体
    ·将客户想要的内容进行返回
        *(什么是http协议，以及功能和特点
        *知道请求和响应的格式和作用
        *知道请求头的种类，基本的响应码的意义
        *了解http请求和响应的完整过程)
--------------------------------------------------------------------------------
基础的http服务流程程序
    ·接收http请求
    ·给出一定的响应
--------------------------------------------------------------------------------
IO  input  output
凡是在内存中存在数据交换的操作都可以认为是IO操作
比如：内存和磁盘交互   读写  read write
      内存和终端交互  print  input
      内存和网络交互  recv    send
--------------------------------------------------------------------------------
IO密集型程序
    ·程序的执行过程中进行大量的IO操作，而只有较少的cpu运算(特点：小号计算机资源较少，运行时间长)
cpu密集型程序(计算密集型):
    ·程序运行中需要大量的cpu运算，IO操作较少(消耗cpu资源多，运行速度快)
IO分类：
    ·阻塞IO   非阻塞IO    IO多路复用    事件IO    异步IO
阻塞IO：
    IO的默认形态，效率很低
    阻塞情况：
        1.因为某种条件没有达到造成的阻塞
        (e.g. input accept   recv)
        2.处理IO事件的时间消耗较长
        (e.g. 文件读写过程，网络数据发送过程)
非阻塞IO：
    通过修改IO事件的属性，使其变为非阻塞状态，即避免条件阻塞的情况
    非阻塞IO往往和循环搭配使用，这样可以不断执行部分需要执行的代码，也不影响对阻塞条件的判断
        s.setblocking()
            功能：设置套接字为非阻塞
            参数：设置为False则套接字调用函数为非阻塞
超时检测：
    将原来阻塞的IO设置一个最长的阻塞等待时间，在规定时间内如果达到条件则正常执行，如果时间仍然未达到条件则结束阻塞
s.settimeout(sec)  #sec等于秒数
    功能：设置套接字超时时间
    参数：设置的时间
IO多路复用：
    定义：同时监控多个IO事件，当哪个IO事件准备就绪，就执行哪个IO事件。此时形成多个IO事件都可以操作的现象，不必逐个等待执行。
准备就绪：IO事件即将发生的临界状态
import select
select     ------>支持windows,linux,unix
poll       ------>支持linux,unix
epoll      ------>支持linux,unix
r,w,x = select(rlist,wlist,xlist[,timeout])
功能：监控IO事件，阻塞等待IO事件发生
参数：
     rlist       列表            要监控的读IO事件(存放被动等待处理的IO事件)
     wlist       列表            要监控的写IO事件(存放需要主动处理的IO)
     xlist       列表            要监控的出错IO事件(存放如果发生异常需要处理的IO)
     timeout     超时时间
返回值：
    r       列表     rlist中准备就绪的IO
    w       列表     wlist中准备就绪的IO
    x       列表     xlist中准备就绪的IO
注意事项：
    1.IO多路复用 处理IO的过程中不应该有死循环出现，使一个客户端长期占有服务端
    2.IO多路复用是一种并发行为，但是是但进程程序，效率较高

位运算：
    按照二进制运算操作
    &  按位与
    |  按位或
    ^  按位异或
    << 左移
    >> 右移
11 & 14 --->10
11 | 14 --->15
11 ^ 14 --->5
11 << 14 --->180224
11 >> 14 --->0

详解请见    位运算符.pdf

使用：
    1.在底层做硬件寄存器的操作
    2.做标志位的过滤选择
作业：
    写一个select服务端，同时关注客户端连接，客户端发送消息，和终端输入。将客户端发送内容和终端输入的内容都按行写入到一个文件里
---------------------------------day04------------------------------------------
poll:
    from select import poll
    1.创建poll对象
    p = poll()
    2.添加关注的IO
常见的poll IO事件分类：
    POLLIN       POLLOUT    POLLERR       POLLHUP      POLLPRI   POLLNVAL
    rlist         wlist      xlist        断开连接      紧急处理    无效
        ·p.register(s,POLLIN | POLLERR)
        ·p.unregister(s)      取消对IO的关注
    3.进行监控
    events = p.poll()
        ·功能：
            监控关注的IO，阻塞等待IO发生
        ·返回值：
            events是一个列表，列表中每个元素为一个元祖，代表准备就绪需要处理的IO
        events --->[(       fileno,           events),(),()]
                         就绪的IO的fileno     哪个事件就绪
        因为要获取IO对象调用函数  ----> 通过fileno得到对象
        实施方法：
            建立比照字典{s.fileno():s}
    4.处理IO
--------------------------------------------------------------------------------
epoll
    使用方法：与poll的操作基本相同
    *生成对象使用epoll()而不是poll()
    *register注册事件事件类型改为epoll事件类型
================================================================================
        select     poll       epoll
        1.select可以很好的支持Windows
        2.epoll比select和poll效率高，select和poll差不多
        3.epoll提供了更多的触发方式
--------------------------------------------------------------------------------
本地套接字：
    linux文件类型：
        b   块设备文件   c  字符设备文件   d  目录  - 普通文件    l 链接
        s 套接字 p 管道
    作用：用于本地不同程序间进行通信
本地套接字的流程：
    1.创建套接字对象
        sockfd = socket(AF_UNIX,SOCK_STREAM)
    2.绑定本地套接字文件
        sockfd.bind(path)
        path:一个文件
    3.监听

    4.接收发送消息
--------------------------------------------------------------------------------
os.path.exists(path)
功能：
    判断一个文件夹下是否有某个文件
os.unlink() or os.remove()
功能：删除一个文件

--------------------------------------------------------------------------------
多任务编程：
    意义：充分利用计算机的资源提高程序的运行效率
    定义：通过应用程序利用计算机多个核心，达到同时执行多个任务的目的。
    实施方案：多进程，多线程

并行
    多个计算机核心在同时处理多个任务，多个任务之间是并行关系
并发
    计算机同时处理多个任务，内核在多个任务间不断切换，达到好像在同时处理的效果。此时多个任务实际为并发关系
        进程：程序在计算机中运行一次的过程
        程序：是一个可执行文件，是静态的，占有磁盘，不占有计算机运行资源
        进程：进程是一个程序的动态描述，占有cpu内存等计算机资源的，有一定的生命周期
        *同一个程序的不同执行过程是不同的进程，因为分配的计算机资源等均不同。
进程的创建流程：
    1.用户空间运行一个程序，发起进程创建
    2.操作系统开启接收用户请求，开启进程创建
    3.操作系统分配系统资源，确认进程状态
    4.将创建好的进程提供给应用层使用

cpu时间片：
    如果一个进程占有计算机核心，我们称为该进程在cpu时间片上。多个任务实际对cpu会进行争夺，一般由操作系统来分配cpu时间片

PCB(进程控制块)：
    在操作系统中，进程创建后会自动产生一个空间存放进程信息，称为进程控制块。

进程信息：进程的PID(在进程的唯一编号，操作系统自动分配) 进程占有的内存位置   创建时间 用户等。
进程信息查看命令：
    ps -aux
进程特征：
    *进程是操作系统分配资源的最小单位
    *每个进程都有自己单独的虚拟内存空间
    *进程间的执行相互独立，互不影响
进程的状态：
    三态
        *就绪态：进程具备执行条件，等待系统分配cpu
        *运行态：进程占有cpu处理器，处于运行状态
        *等待态：进程暂时不具备运行条件，需要阻塞等待
    五态
        *新建态：创建一个新的进程，获取资源的过程
        *就绪态：进程具备执行条件，等待系统分配cpu
        *运行态：进程占有cpu处理器，处于运行状态
        *等待态：进程暂时不具备运行条件，需要阻塞等待
        *终止态：进程结束，释放资源的过程
通过ps -aux   ------>(STAT)查看运行状态
    ·D 等待态   (不可中断等待)
    ·S 等待态   (可中断等待)
    ·T 等待态   (暂停状态)
    ·R 运行态   (就绪态 运行态)
    ·Z 僵尸态   ()
    +    前台进程(没加+则是后台进程)
    <    高优先级
    N    低优先级
    l    有进程连接
    s    回话组组长
进程优先级：
    优先级决定了一个进程的权限和占有资源的优先程度
    查看进程优先级：
        top：动态的查看进程优先级
        取值范围：-20 -- 19   -20最高
        指定优先级运行程序：
            nice -9 ./while.py(-指定优先级数字 文件名)
            sudo nice --9 ./while.py
父子进程：
    在系统中除了初始化进程每个进程都有一个父进程，可能有0个或者多个子进程，由此形成父子进程关系。我们认为每个进程都是父进程发起请求创建的。
查看进程数：
    进程(process)
        pstree
    查看父进程PID:ps -ajx
    要求：什么是进程，进程和程序的区别
        了解进程的特征
        清楚进程的状态及状态间的转换关系
        并行和并发的区别，操作系统功能
需求：
    编写一个程序，能够同时执行多个任务。同时要在程序运行过程中根据情况创建进程+
import os
pid = os.fork()
    功能：创建一个新的进程
    参数：无
    返回值：失败返回负数 -1
           成功 在原有进程中返回新的进程的PID
           在新的进程中返回0
*子进程会复制父进程全部代码段，包括fork前的代码
*子进程从fork的下一句开始执行
*父子进程通常会根据fork返回值的差异选择执行不同的代码(使用if结构)
*父子进程在执行上互不干扰，执行顺序不确定
*子进程虽然复制父进程内存空间，但是有自己的特性
 比如PID号，PCB等
 *父子进程空间独立，各自修改各自的内容，互不干扰

 作业：
    写一个聊天室
    功能：类似qq群聊
    1.进入聊天室需要输入用户名
    2.有人进入聊天室 其他人会收到提示
    3.某人发消息，其他人都能收到
    4.有人退出聊天室  其他人会收到提示
    服务端  客户端
    *整体实现方案
    *用什么技术
------------------------------day05---------------------------------------------
进程相关函数使用
    os.getpid()
    功能：获取当前进程的pid号
    返回值：返回pid号

    os.getppid()
    功能：获取父进程的进程号
    返回值：返回pid号

    os._exit(status)
    功能：退出进程
    参数：进程的退出状态 整数

    sys.exit([status])
    功能：退出进程
    参数：默认为0   如果是整数则表示退出状态    如果是字符串则表示退出时打印内容
    * sys.exit 可以通过捕获SystemExit异常阻止退出


孤儿进程：父进程先于子进程退出，此时子进程就会成为孤儿进程。
    孤儿进程会被系统指定的进程收养    即系统进程会成为该孤儿进程新的父进程。孤儿进程退出时，该父进程会处理孤儿进程的退出状态。


僵尸进程：子进程先于父进程退出,父进程没有处理子进程退出状态，此时子进程成为僵尸进程
    僵尸进程已经结束，但是会滞留部分PCB信息在内存，大量的僵尸进程会消耗系统资源，应该尽量避免

如何避免僵尸进程产生
    *父进程先退出
        创建二级子进程
            1.父进程创建子进程等待子进程退出
            2.子进程创建二级子进程，然后马上退出
            3.二级子进程称为孤儿，处理具体事件

    *父进程处理子进程退出状态
        pid,status = os.wait()
        功能：在父进程中阻塞等待处理子进程的退出
        返回值：pid    退出的子进程的PID号
                       status    子进程的退出状态

        pid,status = os.waitpid(pid,option)
        功能：同wait
        参数：pid    -1     表示任意子进程退出
                           >0     整数 指定PID号的子进程退出
                   option    0     表示阻塞等待
                                WNOHANG     表示非阻塞
        返回值：同wait
--------------------------------------------------------------------------------
multiprocessing 模块创建进程
    1.需要将要做的事件封装为函数
    2.使用multiprocessing中提供的Process类创建进程对象
    3.通过进程对象和Process 初始化函数 对进程进行设置，并且绑定要执行的事件
    4.启动进程，会自动执行相关联函数
    5.事件完成后回收进程

创建进程对象
p=Process()
功能：创建进程对象
参数：name : 给创建的进程对象起一个名字（默认为Process-1）
           target : 绑定的函数
           args : 元组 给target函数按照位置传参
           kwargs : 字典 给target函数按照键值传参

p.start()
功能：启动进程，此时进程被创建。自动运行进程函数

p.join([timeout])
功能：阻塞等待回收相应的进程
参数：超时时间

总结：
    1.multiprocessing创建进程是原来进程的子进程，创建后父子进程各自执行互不影响
    2.子进程同样是复制父进程空间，子进程对内容的修改不会影响父进程空间
    3.join回收子进程，会有效阻止僵尸进程产生
    4.通常使用multiprocessing创建进程，父进程只用作进程的创建和回收，不做其他工作
--------------------------------day06-------------------------------------------
multiprocessing进程对象属性
    p.start()  启动进程
    p.join()   回收进程
    p.is_alive() 判断进程生命周期状态 返回True False
    p.name       进程名称默认为Process-1   如果起名则为自定义名称
    p.pid        创建的进程的pid
    p.daemon
        默认值为false  父进程退出不会影响子进程运行
        如果设置为true 则父进程退出，子进程也会退出
        1.daemon的设置必须在start前
        2.如果daemon为True则不再使用join
---------------------------------------------------------------------------------
创建自己的进程类：
	1.继承Process类
	2.重写__init__并且调用父类的__init__
	3.重写run方法，此时生成对象后调用start就会自动运行run

多进程：
	优点：并行执行多个任务，提高效率，创建方便，运行独立，不受其他进程影响
	数据安全
	缺点：进程的创建和删除都需要小号计算机的资源

进程池技术：
原因：
	如果有大量任务需要多进程完成，且可能需要频繁的创建和删除进程，给计算机带来大量
	的资源消耗。
原理：在进程池运行一定数量进程，通过这些进程完成进程池队列中的事件，直到事件执行完
毕，减少进程不断的创建删除过程
实施操作方法：
	1.创建进程池，在进程池中放入适当进程
	2.将事件加入到进程池队列
	3.事件不断运行，直到所有事件运行完毕
	4.关闭进程池，回收进程
from multiprocessing import Pool
Pool(processes)
功能：
	创建进程池对象
参数：
	表示进程池中有多少进程
pool.apply_async(func,args,kwds)
功能：
	将事件放入到进程池队列
参数：
	func 要执行的事件
	args 给func用元组传参
	kwds 给func用字典传参
返回值：
	返回事件对象 通过get()方法获取事件函数返回值 
pool.close()
功能：关闭进程池，不能添加新的事件
pool.join()
功能：
	阻塞等待回收进程池
pool.map(func,iter)
功能：
	将要完成的事件放入进程池
参数：
	func要完成的事件函数
	iter可迭代对象给func传参
返回值：事件函数的返回值列表
------------------获取文件大小的方法------------------------
os.path.getsize(path)
功能：
	获取文件大小
参数：
	文件
------------------------------------------------------------
进程间的通信：
	进程间由于空间独立，资源无法互相直接获取，此时在不同的进程间进行
	数据传递，就需要专门的通信方法
进程间通信方法：(IPC)
	管道    消息队列    共享内存	信号	信号量	套接字

管道通信：pipe
	在内存中开辟一段空间，形成管道结构，管道对多个进程可见，进程可以对管道进行
	读写操作
multiprocessing ----> Pipe
fd1,fd2 = Pipe(duplex = True)
功能：创建一个管道
参数：默认为双向管道
		反则是单向管道
返回值：如果是双向管道，fd1，fd2都可以进行读写操作
		如果是单向管道，则fd1只可读，fd2只可写

f.recv()
功能：
	从管道读取内容
返回值：
	读到的内容
*如果无内容则阻塞
fd.send(data)
功能：
	向管道写入内容
参数：
	要发送的内容
*几乎可以发送python支持的数据

消息队列：
	先进先出
在内存中开辟队列结构空间，多个进程可以向队列投放消息，在取出的时候按照存入序列取出

创建队列：
	q = Queue(maxsize = 0)
功能：
	创建队列
参数：maxsize 默认表示根据系统分配空间存储信息
		如果传入一个正整数则表示最多存放多少条消息
返回值：
	队列对象
q.put(data,[block,timeout])
功能：
	存放消息
参数：
	data 存入的消息(python数据类型)
	block 默认为True表示队列满的时候阻塞
		  设置为False则表示非阻塞
		  timeout 当block为True表示超时时间
data = q.get([block,timeout])
功能：
	block 默认为True表示队列为空时阻塞
		  False表示非阻塞
    timeout 当block为True时表示超时时间

返回值：返回获取的消息
q.full()   判断队列是否为满
q.empty()  判断队列是否为空
q.qsize()  判断当前队列有多少条信息
q.close()  关闭队列

共享内存：
	在内存中开辟一段空间，存储数据，对多个进程可见。没课写入共享内存的数据会覆盖
	之前的内容

from multiprocessing import Value
obj = Value(ctype,obj)
功能：
	开辟共享内存空间
参数：
	ctype 字符串 要转变的c的数据类型
	             对比类型对照表
	obj          共享内存的初始化
返回：
	共享内存对象
obj.value     表示共享内存中的值。对其修改或者使用即可

obj = Array(ctype,obj)
功能：
	开辟共享内存
参数：
	ctype  要转化的c的类型
	obj   要存入共享内存的数据
	     列表  将列表存入共享内存，数据类型必须要一致
	     正整数   表示开辟几个数据空间

开辟空间      管道        消息队列        共享内存
              内存           内存            内存

读写方式    两端读写      先进先出        操作覆盖内存


效率           一般          一般           较快


应用        用于两端通信     使用广泛     复杂，需要同步互斥机制   


作业：
	复习类的使用
	socket代码总结
	进程和网络概念总结
	进程间通信方法，和进程池熟练一下

-------------------------------------day07----------------------------------------
信号：
	一个进程向另一个进程通过信号传递某种讯息，接收方在接收到信号后进行相应的处理

查看信号：
	kill -l
	kill -signum PID  给PID的进程发送一个信号

关于信号：
	信号的名字或者数字

信号含义：
	信号的作用

默认行为：
	当一个进程接收到信号时采取的行为终止进程，暂停进程，忽略产生

e.g.

SIGHUP      终端断开
SIGINT      ctrl+c
SIGQUIT     ctrl+\
SIGTSTP     ctrl+z
SIGTKILL    终止进程且不能被处理
SIGSTOP     暂停进程且不能被处理
SIGALRM     时钟信号
SIGCHLD     子进程状态改变发给父进程

os.kill(pid,sig)
功能：发送信号给某个进程
参数：
	pid    给那个进程发送信号
	sig    要发送什么信号

signal.alarm(sec)
功能：
	一定时间后给自身发送一个SIGALRM信号
参数：
	指定时间
*一个进程中只能设置一个时钟，第二个时钟会覆盖之前的时间
程序执行的同步和异步
	同步：
		按照步骤一步一步顺序执行
	异步：
		在程序执行中利用内核，不影响应用层程序持续执行
	*信号是唯一的异步通信方式

signal.pause()
功能：
	阻塞等待一个信号的发生

signal.signal(signum,handler)
功能：处理信号
参数：signum:要处理的信号
		handler:信号的处理方法

		SIG_DFL    表示使用默认的方法处理
		SIG_IGN    表示忽略者的信号
		func       表示自定义函数处理信号
			def func(sig,frame):
				pass
			sig:表示要处理的信号
			frame:表示信号的结构对象
			*signal是一个异步处理函数
*signal函数是一个异步处理函数
*signal函数不能处理SIGKILL SIGSTOP信号
*在父进程中使用signal(SIGCHLD,SIG_IGN),这样子进程退出时会有系统自动处理

信号量：
	给定一定的数量，对多个进程可见，并且多个进程根据信号量的多少确定不同的行为

multiprocessing ----> Semaphore()
sem = Semphore(num)
功能：
	生成信号量对象
参数：
	信号量的初始值
返回值：
	信号量对象
sem.acquire()   信号量数量减一   信号量为0时阻塞
sem.release()   信号量加一 
sem.get_value()   获取当前信号量的值 	

同步互斥机制：
	目的：
		解决对共有资源操作产生的争夺
临界资源：
	多个进程或者线程都能够操作的资源
临界区：
	操作临界资源的代码段

同步：
	是一种合作关系，为完成某个人物，多进程或者多线程之间形成一种协调。按照约定依次执行
	对临界资源的操作，相互告知，相互促进

互斥：
	是一种制约关系，当一个进程战友临界资源就会进行加锁的操作，此时其他进程就无法操作该临界资源。
	直到使用的进程进行解锁操作后才能使用。

Event事件：

multiprocessing ----> Event

创建事件对象：
e = Event()

事件阻塞：
e.wait([timeout])

事件设置：
e.set()
功能：
	当e被set()后，e.wait()不再阻塞

事件清除：
e.clear()
功能：
	当e被clear()后，e.wait()又会进入阻塞状态

事件判断  判断当前事件对象是否被设置
e.is_set()

锁  lock
    multiprocessing ----> Lock

创建对象：
    lock = Lock()
    lock.acquire()   上锁
    lock.release()   解锁

上锁状态：执行acquireq()   操作会阻塞
解锁状态：执行release()   不阻塞

with lock:  ----->上锁
   ....
   ....
     ---->with代码段结束即解锁

线程：
    什么是线程：
        线程也是一种多任务编程的方式，可以使用计算机多核资源
        线程又被称为轻量级的进程

线程特征：
    *线程是计算机核心分配的最小单位
    *一个进程可以包含多个线程
    *线程也是一个运行过程，也要消耗计算机资源。多个线程共享其进程的资源和空间
    *线程也拥有自己特有的资源属性，比如指令集，TID等
    *线程无论是创建还是删除，资源消耗都小于进程
    *多个线程之间并行执行，互不干扰


创建线程：
    threading 模块创建线程
    threading.Thread()
    功能：
        创建线程对象
    参数：
        name  线程名称
        target 线程函数
        args   给线程函数传参
        kwargs 字典  给线程函数传参
t.start()   启动线程
t.join([timeout])  回收线程

线程属性：
    t.is_alive()     查看线程状态
    t.name()   线程名称
    t.setName()   设置线程名称
    threading.currentTread()  获取当前线程对象
t.daemon
默认情况下，主线程的结束不会影响分支线程
如果设置为True则主线程退出分支线程也会退出

设置方法：
    t.daemon =True
    t.setDaemon(True)

判断daemon属性：
    t.isDaemon()

*线程daemon属性的设置在start前
*一般设置daemon后不会使用join

创建自己的线程类：
    1.继承Thread类
    2.运行Thread类中的__init__方法获取父类属性
    3.重写run方法	


作业：
    1.复习网络编程(tcp udp http)
    2.司机和售票员的故事：
        *创建父子进程，分别司机售票员
        *当售票员捕捉到SIGINT信号，发送给司机SIGUSER1信号，司机打印“老司机开车了”
           当售票员捕捉到SIGQUIT信号，发送给司机SIGUSER2信号，司机打印“车速有点快，系好安全岛”
        *当司机捕捉到SIGSTP信号，给售票员发送SIGUSER1，此时售票员打印‘到站了请下车’
        *到站后，售票员先下车(子进程先退出)，然后司机下车

-------------------------------------------------------day08-------------------------------------------------

线程通信：
    通信方法：多个线程公用进程空间，所以进程的全局变量对进程内的线程均可见。因此使用全局变量通信是线程主要
    通信方法

注意事项：
    线程间通信更容易产生资源争夺，往往需要同步互斥机制保证通信安全

线程的同步互斥：
    线程的Event事件

操作：
    e = threading.Event()
    e.wait([timeout])   如果e为设置状态则不阻塞，未设置则阻塞
    e.set()   将e变为设置状态
    e.clear()   将e设置去除

线程锁：
    lock = threading.Lock()  创建锁
    lock.acquire()      上锁
    lock.release()      解锁
操作原理：
    重复上锁   acquire会阻塞

python线程的缺点GIL问题(全局解释器锁):
    超级锁(给解释器加锁)：
        后果：
            一个解释器，同一时刻只能解释一个线程。大大降低了python多项城的执行效率

python的GIL问题的解决方案：
    *尽量使用进程
    *不使用c作为解释器
    *python线程适用于高延迟的IO操作，网络操作，不适合cpu密集型或者传输速度很快的IO操作
    **注意：
        线程遇到阻塞会让出解释器
效率测试：   
    继承的效率明显提高，由于GIL影响线程效率较低

进程和线程的区别和联系：
    1.两者都是多任务编程的方式，都能使用计算机多核资源
    2.进程的创建和删除要比线程消耗更多的计算机资源
    3.进程空间独立，数据安全性好，有专门的通信方法
    4.线程使用全局变量通信，更加简单，但是往往需要同步互斥机制
    5.一个进程可以包含多个线程，线程共享进程的资源
    6.进程线程都有自己的特有属性资源，如命令，属性，id等


使用场景：
    如果需要创建较多的并发，人物比较简单，线程比较合适
    如果数据操作和功能比较独立，此时使用进程比较合适
    使用线程时，要考虑到同步互斥的复杂程度
    python线程需要考虑到GIL问题


总结：
    1.进程线程的特征
    2.进程线程区别和关系
    3.同步互斥的意义，用过什么方法，什么情况下用的
    4.进程间通信方式都有哪些
    5.僵尸进程如何处理
    6.给一个场景，如何选择进程还是线程，为什么？

服务器模型：
    硬件服务器：
        主机    集群    
        厂商：IBM HP 联想 浪潮
软件服务器：
    编写的服务端程序，依托于硬件服务器运行，提供给用户一定的软件服务
        分类：
            webserver    -----> 网站后端程序提供网站请求的后端处理和相应
            httpserver   -----> 处理http请求，回复http响应
            邮箱服务器   -----> 处理邮件的
            文件服务器   -----> 处理文件传输的
功能：
    网络连接，逻辑处理，数据的交互，数据的传输，协议的实现

模型结构：
    c/s   (客户端服务器模型)
    b/s   (浏览器服务器模型)

服务器目标：
    处理速度快
    数据更安全
    并发量大

硬件层面：
    更高的配置，集成分布基础，更好的网络速度，更多的主机，更好的网络安全性

软件：
    程序占有更少的资源，更稳定的运行效果，更流畅的运行速度，采用更安全更合适的技术

基础的服务器模型：
    1.循环服务器
        单进程程序，循环接收客户端请求，处理请求，每处理完一个请求再去接收下一个请求。
            优点：
                循环简单，占用资源少
            缺点：
                无法同时连接多个客户端，当一个客户端长期占有一个服务器时，形成其他
                客户端无法操作的情况
            使用情况：
                任务比较短暂，udp套接字更合适

    2.并发服务器：能同时处理多个客户端的请求
        IO并发
            IO多路复用                                 协程
        优点：资源消耗相对较小，效率较高，
                适用于IO类型的服务器
        缺点：
            不能监控cpu密集型程序，本质是
            单进程，不能长期阻塞消息的收发

        多进程/多线程并发
            为每一个客户端单独提供一个进程或者线程处理请求，
            由于进程线程执行独立，所以对其他进程不会有影响
        优点：
            客户端可以长期占有服务器，操作不会对其他进程线程
            产生影响
        缺点：
            消耗资源较多

多进程并发：
    使用fork完成并发
        1.创建套接字，绑定，监听
        2.等待接收客户端请求   accept
        3.创建子进程处理客户端请求
          父进程继续等待其他客户端连接
        4.客户端退出则子进程退出

tftp 文件服务器：
    功能要求：
        *客户端有简单的命令提示界面
        *根据提示可以选择相应的功能
            1.查看服务器文件库的文件列表(只显示普通文件)
            2.可以下载其中的某个文件到本地
            3.可以将本地文件上传到文件库中
            4.退出
        *服务器需求：
            1.能够处理客户端各种请求
            2.允许客户端同时访问操作
1.技术分析(用什么套接字[tcp]   需要服务器模型[多进程并发]  需要注意的问题[粘包问题，僵尸进程]   
            数据如何传输[文件名传输 注意粘包处理 文件传输注意传输结尾])
2.设计整体结构：
    要求封装为类，将功能函数写入类中
    class Tftpservers():
        def __init__():
            ....
        def get():
            ....
        def put():
            ....
        def list():
            ....

    main()控制整体流程
        创建套接字
        接收客户端连接
        创建子进程
        父进程继续等待连接
--------------------------------------------day09-----------------------------------------------------
cookie：
    os.listdir(PATH)   #PATH文件夹   
        *获取文件夹下的文件列表
    os.path.isfile()
        *判断文件的类型是否为普通文件
    os.path.isdir()
        *判断一个文件的类型是否为目录

threading的多线程并发：
    每有一个客户端就创建一个新的线程处理客户端请求
对比多线程：
    优点：资源消耗少
    缺点：需要处理共享资源注意GIL问题

实现步骤：
    1.创建套接字，绑定，监听
    2.接收客户端请求，创建新的线程
    3.主线程继续等待其他客户端连接，分支线程执行客户端请求
    4.处理完客户端请求后，分支线程退出，关闭客户端套接字

socket 服务器的集成模块：
    python2 SocketServer
    python3 socketserver        
功能：
    通过模块的接口，完成基于多进程/或多线程的tcp/udp的socket并发程序

基于多线程并发的HTTPServer：
    1.接收浏览器的http请求
    2.对请求进行解析
    3.根据解析判断请求内容
    4.将要返回的内容组织http相应格式发送给客户端
升级：
    *使用多线程并发
    *增加具体请求解析
    *增加数据 获取功能
    *封装使用类

技术实现：
    threading    并发
    tcp socket   传输
    HTTP协议响应和请求的格式

作业：
    1.总结进程下线程和网络中的概念问答题
    2.聊天室，文件服务器，httpserver第二版
    3.复习规划


    





